//************************\\//**************************\\
//**Smarthouse IoT Blynk**\\//**Created by Maxim Kotov**\\
//************************\\//**************************\\
////////////////////////////

#define BLYNK_PRINT Serial
#include <WiFi.h>
#include <WiFiClient.h>
#include <Adafruit_ADS1015.h>
#include <BlynkSimpleEsp32.h>
#include <Wire.h>
#include <SPI.h>                       // конфигурация блинка // Blynk configuration 

#include "TLC59108.h"
#define HW_RESET_PIN 0 // Только програмнный сброс
#define I2C_ADDR TLC59108::I2C_ADDR::BASE
TLC59108 leds(I2C_ADDR + 7); // Без перемычек добавляется 3 бита адреса
TLC59108 leds2(I2C_ADDR + 0); // Без перемычек добавляется 3 бита адреса   // RGB модуль
TLC59108 leds3(I2C_ADDR + 6); // Без перемычек добавляется 3 бита адреса   // RGB модуль
#include <ESP32_Servo.h>                      // конфигурация сервомотора // servo configuration

#include "Adafruit_SGP30.h"      // датчик газа
Adafruit_SGP30 sgp30;

#include <VL53L0X.h>    /// датчик расстояния
VL53L0X lox;
#define HIGH_ACCURACY

#define sensor_addr 0x39         // датчик пламени
float ir_data = 0;
float vis_data = 0;

#include <Adafruit_MCP4725.h>                           // динамик
Adafruit_MCP4725 buzzer;
int ton;
int vol1 = 1000; // Уровень громкости = vol1-vol2
int vol2 = 900;  //

#include <Adafruit_LSM9DS1.h>                       // гироскоп
Adafruit_LSM9DS1 lsm = Adafruit_LSM9DS1();

#include <I2C_graphical_LCD_display.h>            // дисплей
I2C_graphical_LCD_display lcd;

#include "mcp3021.h"
uint8_t adcDeviceId =  0b00000001; // Адрес микросхемы A0
MCP3021 mcp3021;
const float air_value = 570.0;
const float water_value = 335.0;
const float moisture_0 = 0.0;
const float moisture_100 = 100.0;

#include "MCP3221.h"            // микрофон
const byte DEV_ADDR = 0x4D;
MCP3221 mcp3221(DEV_ADDR);

#define  pump   16                     // пин насоса // pump pin             
#define  wind   17                     // пин вентилятора // cooler pin 
#define  amper  14                     // пин амперметра
#define  button 4                      // пин кнопки

Servo myservo;
int pos = 1;            // начальная позиция сервомотора // servo start position
int prevangle = 1;      // предыдущий угол сервомотора // previous angle of servo

const byte picture [] PROGMEM = {      // картинка
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0,
  0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0x80, 0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFE,
  0xF8, 0xF0, 0xE0, 0xF0, 0xF8, 0xFC, 0x7F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
  0x00, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x07, 0x03, 0x03, 0x01, 0xE1, 0xE1, 0xE1, 0xE3, 0xE3,
  0xE3, 0xE3, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xF8, 0xF8,
  0xF8, 0xF9, 0xFF, 0xFF, 0xFF, 0xDF, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFC, 0xFF, 0xFF,
  0xFF, 0x0F, 0x03, 0xC3, 0xC1, 0xC0, 0xC0, 0xC4, 0xFC, 0xF8, 0xF9, 0xF1, 0x03, 0x07, 0x1F, 0xFF,
  0xFF, 0xFE, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
  0x03, 0x07, 0x0F, 0x07, 0x03, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
  0x00, 0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFC, 0xF8, 0xF0, 0xF0, 0xF1, 0xF1, 0xF1, 0xFF, 0xFF,
  0xFF, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xF1, 0xF1,
  0xF1, 0xF1, 0xF1, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFC, 0xF0, 0xE0, 0xE1, 0xC3, 0xC7, 0xC7, 0xC7, 0xC7, 0xC3, 0xE1, 0xF0, 0xF8, 0xFE, 0xFF,
  0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

char ssid[] = "XXXXXXXXX";                            // Логин Wi-Fi  // Wi-Fi login
char pass[] = "XXXXXXXXXXXX";                    // Пароль от Wi-Fi // Wi-Fi password
char auth[] = "XXXXXXXXXXXXXXXXXXXXXXXXXX"; // Токен // Authorization token
IPAddress blynk_ip(139, 59, 206, 133);            // конфигурация блинка // Blynk configuration

#include <BH1750FVI.h>        // добавляем библиотеку датчика освещенности // adding Light intensity sensor library  
BH1750FVI LightSensor_1;      // BH1750

#include <Adafruit_Sensor.h>  // добавляем библиотеку датчика температуры, влажности и давления // adding Temp Hum Bar sensor library
#include <Adafruit_BME280.h>  // BME280                         
Adafruit_BME280 bme280;       //

#define UPDATE_TIMER 3333
BlynkTimer timer_update;      // настройка таймера для обновления данных с сервера BLynk // Blynk update timer configuration
#define UPDATE_button 250
#define UPDATE_sound 25


//////////////////////////////////////////НАСТРОЙКИ/CONFIGURATION/////////////////////////////////////////////////////////////////
void setup()
{
  myservo.attach(13);             // пин сервомотора // servo pin

  init_sensor();

  lcd.begin();
  lcd.gotoxy (0, 0);
  lcd.clear (0, 0, 128, 64, 0x00);  // очищаем поле дисплея



  pinMode( pump, OUTPUT );
  pinMode( button, INPUT );
  pinMode( wind, OUTPUT );       // настройка пинов насоса и вентилятора на выход // pump and cooler pins configured on output mode
  digitalWrite(pump, LOW);       // устанавливаем насос и вентилятор изначально выключенными // turn cooler and pump off
  digitalWrite(wind, LOW);

  Serial.begin(115200);

  delay(512);
  Blynk.begin(auth, ssid, pass, blynk_ip, 8442);         // подключение к серверу Blynk // connection to Blynk server

  Wire.begin();
  leds.init(HW_RESET_PIN);
  leds.setLedOutputMode(TLC59108::LED_MODE::PWM_IND);
  leds2.init(HW_RESET_PIN);
  leds2.setLedOutputMode(TLC59108::LED_MODE::PWM_IND);
  leds3.init(HW_RESET_PIN);
  leds3.setLedOutputMode(TLC59108::LED_MODE::PWM_IND);

  buzzer.begin(0x61); // С перемычкой адрес будет 0x60
  buzzer.setVoltage(0, false);   // выключение звука
  delay(1000);

  if (!sgp30.begin())
    Serial.println("Sensor SGP30 not found!");

  if (!lsm.begin())
  {
    Serial.println("Oops ... unable to initialize the LSM9DS1. Check your wiring!");
    while (1);
  }
  Serial.println("Found LSM9DS1 9DOF");
  lsm.setupAccel(lsm.LSM9DS1_ACCELRANGE_2G);
  lsm.setupMag(lsm.LSM9DS1_MAGGAIN_4GAUSS);
  lsm.setupGyro(lsm.LSM9DS1_GYROSCALE_245DPS);

  LightSensor_1.begin();              // запуск датчика освещенности // turn the light intensity sensor on
  LightSensor_1.setMode(Continuously_High_Resolution_Mode);

  lox.init();
  lox.setTimeout(500);
#if defined LONG_RANGE
  // lower the return signal rate limit (default is 0.25 MCPS)
  lox.setSignalRateLimit(0.1);
  // increase laser pulse periods (defaults are 14 and 10 PCLKs)
  lox.setVcselPulsePeriod(VL53L0X::VcselPeriodPreRange, 18);
  lox.setVcselPulsePeriod(VL53L0X::VcselPeriodFinalRange, 14);
#endif
#if defined HIGH_SPEED
  // reduce timing budget to 20 ms (default is about 33 ms)
  lox.setMeasurementTimingBudget(20000);
#elif defined HIGH_ACCURACY
  // increase timing budget to 200 ms
  lox.setMeasurementTimingBudget(200000);
#endif

  bool bme_status = bme280.begin();
  if (!bme_status)
    Serial.println("Could not find a valid BME280 sensor, check wiring!");  // проверка  датчика температуры, влажности и давления // checking the temp hum bar sensor

  ledcSetup(5, 50, 10);
  ledcAttachPin(amper, 5);

  timer_update.setInterval(UPDATE_TIMER, readSendData);  // включаем таймер обновления данных  // turn on the update timer
  timer_update.setInterval(UPDATE_button, butt);
  timer_update.setInterval(UPDATE_sound, sound);
  
  mcp3021.begin(adcDeviceId);
}
//////////////////
void sound() {                    //  зажигется красный если есть отклонение по оси Х, также открывется картинк на дисплее если был задетекчен звук
  float snd = mcp3221.getVoltage();
  Serial.println(snd);
  lsm.read();
  sensors_event_t a, m, g, temp;
  lsm.getEvent(&a, &m, &g, &temp);
  if (a.acceleration.x > 0.00 or a.acceleration.x < -0.20) {
    leds.setBrightness(3, 0xff);
  }
  else {
    leds.setBrightness(3, 0x00);
  }
  if (snd < 1030) {
    lcd.blit (picture, sizeof picture);
  }
  float dist = lox.readRangeSingleMillimeters();
  if (dist < 100) {
    leds3.setBrightness(2, 0xFF);
  }
  else {
    leds3.setBrightness(2, 0x00);
  }
  poll_sensor();
  if (ir_data>700){
        leds3.setBrightness(1, 0xFF);
  }
  else {
    leds3.setBrightness(1, 0x00);
}
  float l = LightSensor_1.getAmbientLight();
  if(l<150){
    leds.setBrightness(0, 0xFF);
    leds2.setBrightness(0, 0xFF);
    leds3.setBrightness(0, 0xFF);
      leds.setBrightness(6, 0xFF);
    leds2.setBrightness(6, 0xFF);
    leds3.setBrightness(6, 0xFF);
  }
  else{
     leds.setBrightness(0, 0x00);
    leds2.setBrightness(0, 0x00);
    leds3.setBrightness(0, 0x00);
      leds.setBrightness(6, 0x00);
    leds2.setBrightness(6, 0x00);
    leds3.setBrightness(6, 0x00);
  }
}
////////////////              //
void butt() {                         // при нажатии кнопки загорается светодиод в блинке, загорается красный и уФ в ргб модулях и картинк исчезает
  WidgetLED led1(V19);
  int ledstate = 0;
  ledstate = digitalRead(button);
  if (ledstate == HIGH) {
    led1.off();
  }
  else {
    led1.on();
    for (byte pwm = 0; pwm < 0xff; pwm++) {
      leds.setBrightness(3, pwm);
      leds2.setBrightness(1, pwm);
      leds2.setBrightness(4, pwm);
      delay(1);
    }
    for (byte pwm = 0xfe; pwm < 0xff; pwm--) {
      leds.setBrightness(3, pwm);
      leds2.setBrightness(1, pwm);
      leds2.setBrightness(4, pwm);
      delay(1);
    }
    lcd.clear (0, 0, 128, 64, 0x00);
  }
}
//////////////////////////////////////////////////////ЧТЕНИЕ И ЗАПИСЬ ДАННЫХ ДАТЧИКОВ/SENSOR DATA SEND/READ////////////////////////////////////////////////
void readSendData() {

 float adc0 = mcp3021.readADC();
  float hum = map(adc0, air_value, water_value, moisture_0, moisture_100);
    Blynk.virtualWrite(V1, hum); delay(2);        // Отправка данных на сервер Blynk  Давление    // Pressure data send



  float t = bme280.readTemperature();
  float h = bme280.readHumidity();
  float p = bme280.readPressure() / 100.0F;
  Blynk.virtualWrite(V14, t); delay(2);        // Отправка данных на сервер Blynk  Температура // Temperature data send
  Blynk.virtualWrite(V15, h); delay(2);        // Отправка данных на сервер Blynk  Влажность   // Humidity data send
  Blynk.virtualWrite(V16, p); delay(2);        // Отправка данных на сервер Blynk  Давление    // Pressure data send




  float eco2 = 0;
  float tvoc = 0;
  sgp30.IAQmeasure();
 // if (!sgp30.IAQmeasure())
 // {
  //  Serial.println("Measurement failed!");
  //  return;
 // }
  tvoc = sgp30.TVOC;
  eco2 = sgp30.eCO2;
    Serial.println(tvoc);
      Serial.println(eco2);
  Blynk.virtualWrite(V12, tvoc); delay(2);        // Отправка данных на сервер Blynk  Влажность   // Humidity data send
  Blynk.virtualWrite(V13, eco2); delay(2);        // Отправка данных на сервер Blynk  Давление    // Pressure data send
}
/////////////////////////////////////////////////ГЛАВНЫЙ ЦИКЛ/MAIN LOOP///////////////////////////////////////////////////////////////////////////////
void loop()
{

  Blynk.run();                                          // запуск Blynk  // turn Blynk on
  timer_update.run();
}
////////////////////////////////////////////////ДВЕРЬ/DOOR///////////////////////////////////////////////////////////////////////////////////
BLYNK_WRITE(V0)
{
  int angle = param.asInt();
  if (prevangle < angle) {
    for (pos = prevangle; pos <= angle; pos += 1)
    {
      myservo.write(pos);
      delay(5);                                        // если угол задан больше предыдущего, то доводим до нужного угла в ++ // if the current angle>previous angle then going clockwise
    }
    prevangle = angle;
  }
  else if (prevangle > angle) {
    for (pos = prevangle; pos >= angle; pos -= 1)
    {
      myservo.write(pos);
      delay(5);                                       // если угол задан меньше предыдущего, то доводим до нужного угла в -- // if the current angle<previous angle then going counter-clockwise
    }
    prevangle = angle;
  }
}

//////////////////////////////////////////////НАСОС/PUMP///////////////////////////////////////////////////////////////
BLYNK_WRITE(V5)
{
  int buttonstate1 = param.asInt ();
  if (buttonstate1 == 1) {
    digitalWrite(pump, HIGH);          // включить если нажата кнопка "Насос" // turn on the pump if button = 1
  }
  else    {
    digitalWrite(pump, LOW);
  }
}
//////////////////////////////////////////ВЕНТИЛЯТОР/COOLER/////////////////////////////////////////////////////////////
BLYNK_WRITE(V6)
{
  int buttonstate2 = param.asInt ();
  if (buttonstate2 == 1) {
    digitalWrite(wind, HIGH);         // включить, если нажата кнопка "Вентилятор" // turn on the cooler if button = 1
  }
  else    {
    digitalWrite(wind, LOW);
  }
}
/////////////////////////////////////ЭКРАН///////////////////
BLYNK_WRITE(V4)                         /// картинк и мелодия тетрис
{
  int president = param.asInt ();
  if (president == 1) {
    lcd.blit (picture, sizeof picture);
    note(14, 400); note(2, 100); note(9, 400); note(7, 500); note(14, 300); note(9, 700);      buzzer.setVoltage(0, false); // выключение звука
  }
  else    {
    lcd.clear (0, 0, 128, 64, 0x00);
    buzzer.setVoltage(0, false);   // выключение звука
  }
}

/////////////////////АМПЕРМЕТР///////////////////
BLYNK_WRITE(V18)
{
  int pwr = param.asInt();
  ledcWrite(5, pwr);
  delay(10);
}
////////////////////////////

/////////////////////////////////////////////////////////////////////////// все для музыки
int note( int type, int duration) {   // нота (какая нота, длительность)
  switch (type) {
    case 1:   ton = 1000; break;
    case 2:   ton = 860;  break;
    case 3:   ton = 800;  break;
    case 4:   ton = 700;  break;
    case 5:   ton = 600;  break;
    case 6:   ton = 525;  break;
    case 7:   ton = 450;  break;
    case 8:   ton = 380;  break;
    case 9:   ton = 315;  break;
    case 10:  ton = 250;  break;
    case 11:  ton = 190;  break;
    case 12:  ton = 130;  break;
    case 13:  ton = 80;   break;
    case 14:  ton = 30;   break;
    case 15:  ton = 1;   break;
  }
  delay(10);
  for (int i = 0; i < duration; i++) {
    buzzer.setVoltage(vol1, false);
    buzzer.setVoltage(vol2, false);
    delayMicroseconds(ton);
  }
}
///////////////////////////////////////////////////
void init_sensor() {
  Wire.begin();
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x81);       // Регистр времени интегрирования АЦП
  Wire.write(0b00111111); // 180 мс, 65535 циклов
  Wire.endTransmission();
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x83);       // Регистр времени ожидания
  Wire.write(0b00111111); // 180 мс
  Wire.endTransmission();
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x90);         // Регистр усиления
  Wire.write(0b00000000);   // Усиление 1x
  Wire.endTransmission();
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x80);       // Регистр управления питанием
  Wire.write(0b00001011); // Включение ожидания, генератора, АЦП и ALS сенсора
  Wire.endTransmission();
}

// Получение данных с датчика
void poll_sensor() {
  unsigned int sensor_data[4];
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x94); // Начальный адрес регистров данных
  Wire.endTransmission();
  Wire.requestFrom(sensor_addr, 4);
  if (Wire.available() == 4) {
    sensor_data[0] = Wire.read();
    sensor_data[1] = Wire.read();
    sensor_data[2] = Wire.read();
    sensor_data[3] = Wire.read();
  }
  ir_data   = sensor_data[3] * 256.0 + sensor_data[2];
  vis_data = sensor_data[1] * 256.0 + sensor_data[0];
}
